/**
 * Utility functions to create/load/send zip files
 * 
 * @author Asuman Suenbuel
 */

const JSZip = require('jszip')
const { existsSync, readdirSync, lstatSync, statSync,
	readFileSync, writeFileSync, createWriteStream } = require('fs');
const { ingreen, inblue, inyellow, inblack, inmagenta, incyan } = require('./colorize');
const { removeFolderRecursively, PromiseChain } = require('./server_utils');
const { relative, join } = require('path');

class ZipFile {

    constructor(zip) {
	this.zip = zip || new JSZip()
    }

    /**
     * adds a file at the given path to the zip file. Directories and non-existing files will be ignored
     * @param {string} path the path of the original file
     * @param {string} name the name (path) of the file in the zip file
     */
    addFile(path, name) {
	if (!existsSync(path)) {
	    console.error(`create-zip: ignoring non-existing file "${path}"...`)
	    return
	}
	if (lstatSync(path).isDirectory()) {
	    console.error(`create-zip: ignoring directory "${path}"...`)
	    return
	}
	const _getUnixFilePermission = path => {
	    let stats = statSync(path)
	    //return '0' + (stats.mode & parseInt('777', 8)).toString(8);
	    return stats.mode
	}
	let unixPermissions = _getUnixFilePermission(path)
	//console.log(`create-zip: adding file "${ingreen(path)}" `
	//	    + `(mode ${unixPermissions}) to zip file as "${ingreen(name)}"...`)
	let data = readFileSync(path)
	this.zip.file(name, data, { unixPermissions } )
    }

    addFiles(fileList) {
	fileList.forEach(({ path, name }) => this.addFile(path, name))
    }

    send(response) {
	let filename = 'myattachment.zip'
	this.zip.generateAsync({
	    type: 'nodebuffer',
	    platform: process.platform,
	    comment: '********\n\nZip-file generated by RoseStudio\n\n*******'
	})
	    .then(data => {
		response.header('Content-Type', 'application/zip');
		response.header('Content-Disposition', 'attachment; filename="' + filename + '"');
		response.send(data)
	    })
    }

    /**
     * adds all files in the given folder recursively to the zip
     * file. All paths in the zip file will be relative to the given
     * folder, i.e. the folder itself is not added to the zipfile.
     */
    addFolderRecursively(folder, rootFolder = folder, options) {
	const { dryRun, debug, debugIndent, fileFilterFunction } = options || {};
	const indent = (typeof debugIndent === 'string') ? debugIndent : '';
	debug && console.log(`${indent}addFolderRecursively("${folder}", rootFolder="${rootFolder}")...`);
	const fileFilter = (typeof fileFilterFunction === 'function')
	      ? fileFilterFunction : (() => true);
	if (!lstatSync(folder).isDirectory()) {
	    console.error(`${folder} is not a directory`);
	    return;
	}
	const files = readdirSync(folder).filter(filename => {
	    if (filename === ".rose") return false;
	    if (filename === ".git") return false;
	    if (!fileFilter(filename)) return false;
	    //if (filename === "node_modules") return false;
	    if (filename.endsWith('~')) return false;
	    return true;
	});
	files.forEach(filename => {
	    const filepath = join(folder, filename);
	    if (lstatSync(filepath).isDirectory()) {
		debug && console.log(`${indent}${filepath} is a directory`);
		options.debugIndent = `${indent}    `;
		this.addFolderRecursively(filepath, rootFolder, options);
		return;
	    }
	    const name = relative(rootFolder, filepath);
	    debug && console.log(`${indent}adding to zip: file: "${filepath}", name: "${ingreen(name)}"`);
	    if (!dryRun) {
		this.addFile(filepath, name);
	    }
	})
	debug && console.log(`${indent}done addFolderRecursively("${folder}", rootFolder="${rootFolder}")...`);
    }

    getReadStream() {
	return this.zip.generateNodeStream({ streamFiles: true });
    }

    createFile(fileName, callback) {
	this.zip
	    .generateNodeStream({streamFiles:true})
	    .pipe(createWriteStream(fileName))
	    .on('finish', function () {
		console.log(`${fileName} written.`);
		if (typeof callback === 'function') {
		    callback(null)
		}
	    })
    }

    /**
     * extracts the zip file to the given rootFolder in the file system
     */
    extractToFolder(rootFolder, options, callback) {
	const { join } = require('path');
	const fs = require('fs');
	const createFolderPromises = []
	const createFilePromises = [];
	const { zip } = this;
	const { dryRun, clearFolder, debug, deleteFilter } = options || {};
	debug && console.log(inyellow(`extractToFolder: dryRun=${!!dryRun}, clearFolder=${!!clearFolder}`));
	Object.keys(zip.files).forEach(filename => {
	    let zfile = zip.file(filename);
	    if (!zfile) {
		let zfolder = zip.folder(filename);
		if (zfolder) {
		    //console.log(`${filename} is a folder.`);
		    let dest = join(rootFolder, filename);
		    let p1 = () => new Promise((resolve, reject) => {
			debug && console.log(inblue(`creating folder "${dest}"...`));
			if (dryRun) {
			    debug && console.log('[dry run; nothing created]');
			    resolve(dest);
			    return;
			}
			fs.mkdir(dest, { recursive: true }, err => {
			    if (err) {
				return reject(err);
			    }
			    debug && console.log(inmagenta(`folder created: ${dest}`))
			    return resolve(dest);
			});
		    });
		    createFolderPromises.push(p1);
		}
		return;
	    }
	    let p2 = () => new Promise((resolve, reject) => {
		zfile.async('nodebuffer')
		    .then(content => {
			debug && console.log(`content with length ${content.length} retrieved `
				    + `for file "${filename}".`);
			let dest = join(rootFolder, filename);
			debug && console.log(`  --> writing into ${dest}...`);
			if (dryRun) {
			    debug && console.log('[dry run; nothing written]');
			    resolve(dest);
			    return;
			}
			fs.writeFile(dest, content, err => {
			    if (err) {
				return reject(err);
			    }
			    debug && console.log(incyan(`file created: ${dest}`))
			    resolve(dest);
			});
		    })
		    .catch(err => {
			reject(err);
		    });	      
	    });
	    createFilePromises.push(p2);
	});

	// prepend the removeFolder operations if specified
	const clearFolderPromise = clearFolder
	      ? removeFolderRecursively(rootFolder, { dryRun, debug, deleteFilter })
	      : Promise.resolve(null);

	const promiseChain = [clearFolderPromise, ...createFolderPromises, ...createFilePromises];
	//const promiseChain = [clearFolderPromise];
	
	return PromiseChain(promiseChain)
	    .then(() => {
		callback(null);
	    })
	    .catch(err => {
		callback(err);
	    });
    }

    static loadFromBuffer(buf, callback) {
	JSZip.loadAsync(buf)
	    .then(zip => {
		//console.log('zip file created from buffer');
		callback(null, new ZipFile(zip));
	    })
	    .catch(err => {
		const msg = `Error loading zipfile from buffer: ${err}`;
		console.error(msg);
		callback(msg);
	    })
    }
    
}


module.exports = ZipFile
